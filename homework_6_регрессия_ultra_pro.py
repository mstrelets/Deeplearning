# -*- coding: utf-8 -*-
"""Homework 6. Регрессия. Ultra Pro

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SChUQauzKVJVAeJIi2gtMRRhDm7RShRx

Прогнозирование суммы продажи домов с землей на базе продаж 2014-2015 года, Сиэтл
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
from google.colab import files
from tensorflow.keras import utils
import numpy as np
from tensorflow.keras.preprocessing.sequence import pad_sequences
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
# %matplotlib inline

from keras.optimizers import Adam
from keras.models import Sequential, Model
from keras.layers import concatenate, Input, Dense, Dropout, BatchNormalization, Flatten, Conv1D, Conv2D, CuDNNLSTM

from google.colab import drive
drive.mount('/content/drive')

#!unzip -q "/content/drive/My Drive/AI/kc_house_data.csv.zip" -d "/content/drive/My Drive/AI/KCHouses"

df = pd.read_csv('/content/drive/My Drive/AI/KCHouses/kc_house_data.csv', sep=",") #Загружаем данные в data frame
data = df.values #Вытаскиваем данные в numpy array

print(df.iloc[:,:12].head(20)) #Показываем пример данных (первые 6 колонок)

print(sorted(df['bedrooms'].unique()))
print(sorted(df['bathrooms'].unique()))
print(sorted(df['floors'].unique()))

print(sorted(df['waterfront'].unique()))
print(sorted(df['view'].unique()))
print(sorted(df['condition'].unique()))
print(sorted(df['grade'].unique()))
print(df['yr_built'].nunique(), max(df['yr_built']), min(df['yr_built']))
print(sorted(df['yr_built'].unique())[:20])
print(df['yr_renovated'].nunique(), max(df['yr_renovated']))
print(sorted(df['yr_renovated'].unique())[:20])
print(df['zipcode'].nunique())

print(df['sqft_lot'].nunique(), max(df['sqft_lot']), min(df['sqft_lot']))
print(df['sqft_living'].nunique(), max(df['sqft_living']), min(df['sqft_living']))
print(sorted(df['sqft_lot'].unique())[:20])
print(sorted(df['sqft_lot'].unique())[9762:])
print(sorted(df['sqft_living'].unique())[:20])
print(sorted(df['sqft_living'].unique())[1020:])

print(df.columns) #Показываем имена колонок данных
#В xTrain - база числовых значений (всего 14 параметров)
#bedrooms, bathrooms
#sqft_living - жилая площадь, sqft_lot - общая площадь
#floors, Waterfront, View, Grade - число спален не в basement
#???Condition
#sqft_above, sqft_basement
#yr_built, yr_renovated
#zipcode - код района

#В yTrain - Price

"""#Функции разделения на категории

*Разбор данного раздела:* https://youtu.be/K8S1O8lL5TE?t=6726
"""

#Во всех функциях дальше
#d - описание дома, одна строка из data1

#Превращаем bedrooms и Grade (число комнат не в подвале) в one hot encoding
def getBedroomsCategory(d, maxBedrooms, maxGrade):
  
  Bedrooms = int(d[3])
  if (Bedrooms > maxBedrooms):
    Bedrooms = maxBedrooms              
  Bedrooms = utils.to_categorical(Bedrooms, maxBedrooms+1)

  Grade = int(d[11])
  if (Grade > maxGrade):
    Grade = maxGrade  
  Grade = utils.to_categorical(Grade, maxGrade+1)
  return Bedrooms, Grade

#Превращаем bathrooms в категорию
def getBathroomsCategory(d): #, maxBathrooms):
  Bathrooms = float(d[4])
  if (Bathrooms > 0.5 ):
      if (Bathrooms <= 1.25):
          Bathrooms = 1
      elif (Bathrooms <= 2.25):
          Bathrooms = 2
      elif (Bathrooms <= 3.25):
          Bathrooms = 3
      elif (Bathrooms <= 4.25):
          Bathrooms = 4
      elif (Bathrooms <= 5.25):
          Bathrooms = 5
      else: Bathrooms = 6
  else: Bathrooms = 0
  Bathrooms = utils.to_categorical(int(Bathrooms), 7) 
  return Bathrooms

# Превращаем все числовые значения waterfront, view, condition в one hot encoding
def getHouseParams(d):
  Waterfront = utils.to_categorical(int(d[8]), 2)
  View = utils.to_categorical(int(d[8]), 5)
  Condition = utils.to_categorical(int(d[10]), 6)
  return Waterfront, View, Condition

#Определяем категорию года постройки/реновации   
def getYrBuiltCategory(yr_built):

#  yr_built= int(d[14]) 
  
  if (yr_built != 0):
      if (yr_built < 1960):
          yr_built = 1
      elif (yr_built < 1980):
          yr_built = 2
      elif (yr_built < 2000):
          yr_built = 3
      elif (yr_built < 2010):
          yr_built = 4
      elif (yr_built <= 2015):
          yr_built = 5
  else: yr_built = 0
  
  #Превращаем в one hot encoding
  yr_built = utils.to_categorical(yr_built, 6)
  return yr_built

#Определяем категорию площади земельного участка
def getSqftLot(d):

  sqft = float(d[6])
  if (sqft != 0):
    if (sqft < 10000):
      sqft_cat = 1
    elif (sqft < 50000):
      sqft_cat = 2
    elif (sqft < 100000):
      sqft_cat = 3
    elif (sqft < 500000):
      sqft_cat = 4
    else: sqft_cat = 5
  else: sqft_cat = 0     
   
    #Превращаем все категории в one hot encoding
  sqft_lot = utils.to_categorical(sqft_cat, 6)    
  return sqft_lot

#Определяем категорию жил.площади 
def getSqftLiving(d):

    sqft = float(d[5])
    if (sqft != 0):
        if (sqft < 1000):
          sqft_cat = 1
        elif (sqft < 3000):
          sqft_cat = 2
        elif (sqft < 6000):
          sqft_cat = 3
        elif (sqft < 10000):
          sqft_cat = 4
        else: sqft_cat = 5
    else: sqft_cat = 0 
   
    #Превращаем все категории в one hot encoding
    sqft_Living = utils.to_categorical(sqft_cat, 6)    
    return sqft_Living

#Превращаем Floors в категорию [1.0, 1.5, 2.0, 2.5, 3.0, 3.5]
def getFloors(d): #, Floors):  
  Floors = d[7]
  if (Floors < 2):
    Floors = 1
  elif (Floors < 3):
    Floors = 2
  elif (Floors < 4):
    Floors = 3      
  else: Floors = 4

  Floors = utils.to_categorical(int(Floors), 4) 

  return Floors

#Получаем цену
def getPrice(d):
 
  try:
    Price = float(d[2])  #Пробуем превратить в число
  except:
    Price = 0 #Если не получается, возвращаем 0
  
  return Price

#Объединяем все числовые параметры вместе
def getAllParameters(d):
  #Загружаем все данные по отдельности
  Bedrooms, Grade = getBedroomsCategory(d, 5, 4)
  Bathroom = getBathroomsCategory(d)
  Waterfront, View, Condition = getHouseParams(d)
  Floors = getFloors(d)
  yr_built = getYrBuiltCategory(int(d[14]))
  yr_renovated = getYrBuiltCategory(int(d[15]))
  Sqft_living = d[5] #getSqftLiving(d)
  Sqft_lot = np.array(d[6]) #getSqftLot(d)

  #Объединяем в один лист
  out = list(Bedrooms)
  out.extend(Bathroom)
  out.extend(Floors)
  out.extend(Grade)
  out.extend(Waterfront)
  out.extend(View)
  out.extend(Condition)
  out.extend(yr_built)
  out.extend(yr_renovated)
#  out.extend(Sqft_living)
  out.append(Sqft_lot)
  
  return out

#Генерируем обучающую выборку - xTrain
def getXTrain(data):
  
  #Превращаем все строки в data1 в векторы параметров и записываем в xTrain
  xTrain = [getAllParameters(d) for d in data]
  xTrain = np.array(xTrain)
  
  return xTrain

#Генерируем обучающую выборку - yTrain
def getYTrain(data):
  
  #Загружаем лист всех price по всем строкам data
  PriceList = [getPrice(d) for d in data] 
  yTrain = np.array(PriceList)
  
  return yTrain

"""**Формируем обучающую выборку**"""

print(data.shape)

#oneRoomMask = [getRoomsCount(d, 30) == 1 for d in data] #Делаем маску однокомнатных квартир, принцип (getRoomsCount(d, 30) == 1)
#data1 = data[oneRoomMask] #В data1 оставляем только однокомнатные квартиры
#data_train = 

#print(data.shape)
#print(data1.shape)

xTrain = [getAllParameters(d) for d in data]
  xTrain = np.array(xTrain)

PriceList = [getPrice(d) for d in data] 
yTrain = np.array(PriceList)

#xTrain = getXTrain(data)
#yTrain = getYTrain(data)

"""# Нормировка данных"""

#Нормируем размер квартиры в xTrain
xScaler = StandardScaler() #Создаём нормировщик нормальным распределением
xScaler.fit(xTrain[:,-1].reshape(-1, 1)) #Обучаем его на площадях земельного участка (последня колонка в xTrain)
xTrainScaled = xTrain.copy()
xTrainScaled[:,-1] = xScaler.transform(xTrain[:,-1].reshape(-1, 1)).flatten() #Нормируем данные нормировщиком

#Выводим размер и два примера для сравнения
#Не нормированных данных и нормированных
print(xTrainScaled.shape)
print(xTrain[0][-1])
print(xTrainScaled[0][-1])

#Нормируем выход сети - цену дома
yScaler = StandardScaler() #Делаем нормальный нормировщик
yScaler.fit(yTrain.reshape(-1, 1)) #Обучаем на ценах квартир
yTrainScaled = yScaler.transform(yTrain.reshape(-1, 1)) #Нормируем цены квартир

#Выводим размер и два примера для сравнения
#Не нормированных данных и нормированных
print(yTrainScaled.shape)
print(yTrain[0])
print(yTrainScaled[0])

"""#Нейронка

*Разбор данного раздела:* https://youtu.be/K8S1O8lL5TE?t=7250
"""

from keras.callbacks import LambdaCallback
from IPython.display import clear_output

def on_epoch_end(epoch, logs):
  pred = model.predict(xTrainScaled) #xTrainC01[valMask]]) #Полуаем выход сети на проверочно выборке
  predUnscaled = yScaler.inverse_transform(pred).flatten() #Делаем обратное нормирование выхода к изначальным величинам цен 
  yTrainUnscaled = yScaler.inverse_transform(yTrainScaled).flatten() #Делаем такое же обратное нормирование yTrain к базовым ценам
  delta = predUnscaled - yTrainUnscaled #Считаем разность предсказания и правильных цен
  absDelta = abs(delta) #Берём модуль отклонения
  print("Эпоха", epoch, "модуль ошибки", round(sum(absDelta) / len(absDelta), 0)) #Выводим усреднённую ошибку rounded to whole number

# Коллбэки
pltMae = LambdaCallback(on_epoch_end=on_epoch_end)
# = LambdaCallback(on_epoch_end=save_the_best)

#Простая Dense сеть
input1 = Input((xTrainScaled.shape[1],))
#input2 = Input((xTrainC01.shape[1],))

x = Dense(10, activation="relu")(input1)
#x2 = Dense(250, activation="relu")(input2)

#x = concatenate([x1, x2])

x = Dense(100, activation='relu')(x)
x = Dense(10, activation='relu')(x)
x = Dense(1, activation='linear')(x)

model = Model(input1, x)

model.compile(optimizer=Adam(lr=1e-3), loss='mse')
history = model.fit(xTrainScaled, #xTrainC01[~valMask]], 
                    yTrainScaled, 
                    epochs=40, 
                    #validation_data=(xTrainScaled, xTrainC01[valMask]], 
                    #yTrainScaled), 
                    verbose=0,
                    callbacks=[pltMae],
                    validation_split=0.2)

print()
print('Меняем шаг обучения на 1e-4')
model.compile(optimizer=Adam(lr=1e-4), loss='mse')
history = model.fit(xTrainScaled, #xTrainC01[~valMask]], 
                    yTrainScaled, 
                    epochs=200, 
                    #validation_data=(xTrainScaled[valMask], #xTrainC01[valMask]], 
                    #yTrainScaled[valMask]), 
                    verbose=0,
                    callbacks=[pltMae],
                    validation_split=0.2)

print()
print('Меняем шаг обучения на 1e-5')
model.compile(optimizer=Adam(lr=1e-5), loss='mse')
history = model.fit(xTrainScaled, #[~valMask], #xTrainC01[~valMask]], 
                    yTrainScaled, #[~valMask], 
                    epochs=200, 
                    #validation_data=(xTrainScaled[valMask], #xTrainC01[valMask]], 
                    #yTrainScaled[valMask]), 
                    verbose=0,
                    callbacks=[pltMae],
                    validation_split=0.2)

#Проверяем результаты
pred = model.predict(xTrainScaled)#[valMask]) #, xTrainC01[valMask]]) #Полуаем выход сети на проверочно выборке
predUnscaled = yScaler.inverse_transform(pred).flatten() #Делаем обратное нормирование выхода к изначальным величинам цен квартир
yTrainUnscaled = yScaler.inverse_transform(yTrainScaled).flatten() #Делаем такое же обратное нормирование yTrain к базовым ценам
delta = predUnscaled - yTrainUnscaled #Считаем разность предсказания и правильных цен
absDelta = abs(delta) #Берём модуль отклонения
print("Модуль ошибки", sum(absDelta) / len(absDelta)) #Выводим усреднённую ошибку 

#Выводим графики ошибки
plt.plot(history.history['loss'], 
         label='Средняя абсолютная ошибка на обучающем наборе')
plt.plot(history.history['val_loss'], 
         label='Средняя абсолютная ошибка на проверочном наборе')
plt.xlabel('Эпоха обучения')
plt.ylabel('Средняя абсолютная ошибка')
plt.legend()
plt.show()

"""Выводы:


"""